/****************************************************************/
/* 		Author   	 : Mark Ehab                    */
/* 		Date     	 : Feb 10, 2022               	*/
/*              SWC              : TIMER1			*/
/*              Description	 : TIMER1 Program               */
/* 	        Version          : V1.0                         */
/****************************************************************/

#include "Timer1.h"

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                            GLOBAL VARIABLES DEFINITIONS	                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

static float Global_float32Timer1OverflowTime = ((float32)TIMER1_PRESCALER/(float32)TIMER1_MCU_CLK_FREQ) * (float32)TIMER1_OVERFLOW_TICKS;	/* Global Variable to Hold Timer1 Overflow Time */
static void (*TIMER1_pvOverflowCallbackFunc)(void);										/* Pointer to Function to Hold Address of Overflow Function to Be Called Once Timer1 Overflow ISR is Triggered */
static void (*TIMER1_pvComapareMatchACallbackFunc)(void);									/* Pointer to Function to Hold Address of Output Compare Match Channel A Function to Be Called Once Timer1 Compare Match ISR for Channel A is Triggered  */
static void (*TIMER1_pvComapareMatchBCallbackFunc)(void);									/* Pointer to Function to Hold Address of Output Compare Match Channel B Function to Be Called Once Timer1 Compare Match ISR for Channel B is Triggered  */
static void (*TIMER1_pvCaptureEventCallbackFunc)(void);										/* Pointer to Function to Hold Address of Capture Event Function to Be Called Once Timer1 Capture Event ISR is Triggered */

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                           	  PRIVATE FUNCTIONS		                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

/**********************************************************************************/
/* Description     : Calculate Timer1 preload value     			  */
/* Input Arguments : float32 Copy_float32Delay_s , uint32 Copy_uint32OverflowNum	          */
/* Return          : uint16						          */
/**********************************************************************************/
static uint16 TIMER1_uint16CalculateTimer1PreloadVal(float32 Copy_float32Delay_s , uint32 Copy_uint32OverflowNum)
{
	/* Define Some Local Variables */
	uint16 Local_uint16PreloadValue; 	/* Variable to hold preload value to be put in TCNT1 register before Timer1 starts */

	/* Check if passed delay is greater, less or equal to overflow time  */
	if(Copy_float32Delay_s > Global_float32Timer1OverflowTime)
	{
		Local_uint16PreloadValue = TIMER1_OVERFLOW_TICKS * ((float32)Copy_uint32OverflowNum-(Copy_float32Delay_s/Global_float32Timer1OverflowTime));
	}
	else if(Copy_float32Delay_s < Global_float32Timer1OverflowTime)
	{
		Local_uint16PreloadValue = TIMER1_OVERFLOW_TICKS * (1.0f-(Copy_float32Delay_s/Global_float32Timer1OverflowTime));
	}
	else
	{
		Local_uint16PreloadValue = 0;
	}

	return Local_uint16PreloadValue;
}
/**********************************************************************************/
/* Description     : Set duty cycle value of PWM to be generated by Timer1 from   */
/*		     channel A							  */
/* Input Arguments : uint8 Copy_uint8DutyCycleChA			 	          */
/* Return          : uint8						                  */
/**********************************************************************************/
static uint8 TIMER1_uint8SetDutyCycleChA(uint8 Copy_uint8DutyCycleChA)
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;     		/* A variable to hold function error status */

	if(Copy_uint8DutyCycleChA <= 100)
	{
		uint16 Local_uint16CompareMatchAValue;		/* A variable to hold compare match of channel A value to be calculated */

		#if   TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x00FF * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x00FF - (0x00FF * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x01FF * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x01FF - (0x01FF * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x03FF * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x03FF - (0x03FF * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif


                #elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x00FF * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x00FF - (0x00FF * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_NINE_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x01FF * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x01FF - (0x01FF * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_TEN_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x03FF * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = 0x03FF - (0x03FF * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = ICR1 * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = ICR1 - (ICR1 * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_ICR1_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchAValue = ICR1 * ((float32)Copy_uint8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_uint16CompareMatchAValue = ICR1 - (ICR1 * ((float32)Copy_uint8DutyCycleChA * 0.01f));

			#endif
		#endif


		/* Set Calculated Compare Match Value of Channel A */
		TIMER1_vidSetCompareMatchAValue(Local_uint16CompareMatchAValue);

	}
	else
	{
		/* Function is not working as expected */
		Local_uint8ErrorStatus = RT_NOK;
	}

	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Set duty cycle value of PWM to be generated by Timer1 from   */
/*		     channel B							  */
/* Input Arguments : uint8 Copy_uint8DutyCycleChB			 	          */
/* Return          : uint8						                  */
/**********************************************************************************/
static uint8 TIMER1_uint8SetDutyCycleChB(uint8 Copy_uint8DutyCycleChB)
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;     		/* A variable to hold function error status */

	if(Copy_uint8DutyCycleChB <= 100)
	{
		uint16 Local_uint16CompareMatchBValue;		/* A variable to hold compare match of channel B value to be calculated */

		#if   TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x00FF * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x00FF - (0x00FF * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x01FF * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x01FF - (0x01FF * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x03FF * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x03FF - (0x03FF * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif


                #elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x00FF * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x00FF - (0x00FF * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_NINE_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x01FF * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x01FF - (0x01FF * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_TEN_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x03FF * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = 0x03FF - (0x03FF * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = ICR1 * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = ICR1 - (ICR1 * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_ICR1_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = ICR1 * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = ICR1 - (ICR1 * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_OCR1A_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = OCR1A * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = OCR1A - (OCR1A * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_OCR1A_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_uint16CompareMatchBValue = OCR1A * ((float32)Copy_uint8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_uint16CompareMatchBValue = OCR1A - (OCR1A * ((float32)Copy_uint8DutyCycleChB * 0.01f));

			#endif
		#endif


		/* Set Calculated Compare Match Value of Channel B */
		TIMER1_vidSetCompareMatchBValue(Local_uint16CompareMatchBValue);

	}
	else
	{
		/* Function is not working as expected */
		Local_uint8ErrorStatus = RT_NOK;
	}

	return Local_uint8ErrorStatus;
}

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                           	  PUBLIC FUNCTIONS		                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

/**********************************************************************************/
/* Description     : Initialize Timer1 based on selected configurations from      */
/* 		     config file						  */
/* Input Arguments : void						          */
/* Return          : void						          */
/**********************************************************************************/
void TIMER1_vidInit(void)
{
	/******************************************Set TIMER1 Operating Mode*****************************************/
	/* Clear waveform generation bits */
	CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
	CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
	CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
	CLEAR_BIT(TCCR1B,TCCR1B_WGM13);

	/* Check selected Timer1 mode from config file */
	#if   TIMER1_MODE == OVERFLOW_MODE
		/* Set Timer1 to work in overflow mode */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE
		/* Set Timer1 to work in phase-correct PWM mode with 8-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE
		/* Set Timer1 to work in phase-correct PWM mode with 9-bit resolution */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE
		/* Set Timer1 to work in phase-correct PWM mode with 10-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == CTC_OCR1A_MODE
		/* Set Timer1 to work in CTC mode with OCR1A value as top */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE
		/* Set Timer1 to work in FastPWM mode with 8-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_NINE_BIT_MODE
		/* Set Timer1 to work in FastPWM mode with 9-bit resolution */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_TEN_BIT_MODE
		/* Set Timer1 to work in FastPWM mode with 10-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_ICR1_MODE
		/* Set Timer1 to work in PWM Phase and Frequency Correct mode with ICR1 value as top */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_OCR1A_MODE
		/* Set Timer1 to work in PWM Phase and Frequency Correct mode with OCR1A value as top */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE
		/* Set Timer1 to work in phase-correct PWM with ICR1 value as top */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_OCR1A_MODE
		/* Set Timer1 to work in phase-correct PWM with OCR1A value as top */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLEAR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == CTC_ICR1_MODE
		/* Set Timer1 to work in CTC mode with ICR1 value as top */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		CLEAR_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_ICR1_MODE
		/* Set Timer1 to work in FastPWM mode with ICR1 value as top */
		CLEAR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_OCR1A_MODE
		/* Set Timer1 to work in FastPWM mode with OCR1A value as top */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#else
		#error "Wrong Timer1 Mode Configuration !"
	#endif


	/******************************************Set Timer1 Output Compare Match Pin Mode for both channels A & B*****************************************/
	/* Clear Timer1 output compare match pin mode bits for channel A */
	TCCR1A &= TIMER1_OUTPUT_COMPARE_PIN_CHA_MODE_MASK;

	/* Clear Timer1 output compare match pin mode bits for channel B */
	TCCR1A &= TIMER1_OUTPUT_COMPARE_PIN_CHB_MODE_MASK;

	/* Check selected Timer1 mode from config file */
	#if   TIMER1_MODE == OVERFLOW_MODE || TIMER1_MODE == CTC_OCR1A_MODE || TIMER1_MODE == CTC_ICR1_MODE
		/* Check selected Timer1 output compare match channel */
		#if   TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELA
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == TOGGLE
				/* Toggle Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == CLEAR
				/* Clear Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == SET
				/* Set Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Non PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELB
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == TOGGLE
				/* Toggle Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == CLEAR
				/* Clear Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == SET
				/* Set Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Non PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == BOTH_CHANNELS
			/* Channel A */
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == TOGGLE
				/* Toggle Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == CLEAR
				/* Clear Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == SET
				/* Set Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Non PWM) Configuration !"
			#endif
			/* Channel B */
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == TOGGLE
				/* Toggle Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == CLEAR
				/* Clear Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == SET
				/* Set Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Non PWM) Configuration !"
			#endif
		#else
			#error "Wrong Timer1 Output Compare Match Channel Selection !"
		#endif
	#elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE || TIMER1_MODE == FAST_PWM_NINE_BIT_MODE || TIMER1_MODE == FAST_PWM_TEN_BIT_MODE || TIMER1_MODE == FAST_PWM_ICR1_MODE || TIMER1_MODE == FAST_PWM_OCR1A_MODE
		/* Check selected Timer1 output compare match channel */
		#if   TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELA
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Fast PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELB
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Fast PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == BOTH_CHANNELS
		       /* Channel A */
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Fast PWM) Configuration !"
			#endif
		       /* Channel B */
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Fast PWM) Configuration !"
			#endif
		#else
			#error "Wrong Timer1 Output Compare Match Channel Selection !"
		#endif
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE || TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_ICR1_MODE || TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_OCR1A_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_OCR1A_MODE
		/* Check selected Timer1 output compare match channel */
		#if   TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELA
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Phase-Correct PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELB
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Phase-Correct PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == BOTH_CHANNELS
			/* Channel A */
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Phase-Correct PWM) Configuration !"
			#endif
			/* Channel B */
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Phase-Correct PWM) Configuration !"
			#endif
		#else
			#error "Wrong Timer1 Output Compare Match Channel Selection !"
		#endif
	#else
		#error "Wrong Timer1 Mode Configuration !"
	#endif


	/******************************************Initialize Input Capture Unit (If Enabled)*****************************************/
	/* Check if Timer1 Hardware ICU Mode is Enabled or Not  */
	#if TIMER1_ICU_ENABLE == ENABLE
		/* Check selected Timer1 mode from config file */
		#if TIMER1_MODE != PHASE_FREQUENCY_CORRECT_PWM_ICR1_MODE && TIMER1_MODE != PHASE_CORRECT_PWM_ICR1_MODE && TIMER1_MODE != CTC_ICR1_MODE && TIMER1_MODE != FAST_PWM_ICR1_MODE
				/* Clear ICES1 Bit in TCCR1B */
				CLEAR_BIT(TCCR1B,TCCR1B_ICES1);

				/* Check Timer1 Input Capture Event Trigger Edge Type */
				#if   TIMER1_ICU_TRIGGER_EDGE == FALLING_EDGE
					/* Set Timer1 Input Capture Event Trigger Edge as Falling Edge */
					CLEAR_BIT(TCCR1B,TCCR1B_ICES1);
				#elif TIMER1_ICU_TRIGGER_EDGE == RISING_EDGE
					/* Set Timer1 Input Capture Event Trigger Edge as Rising Edge */
					SET_BIT(TCCR1B,TCCR1B_ICES1);
				#else
					#error "Wrong Timer1 Input Capture Event Trigger Edge Configuration !"
				#endif
		#endif
	#endif


        /******************************************Enable/Disable Timer1 Interrupts*****************************************/
	/* Check if Timer1 overflow interrupt is enabled or not from config file */
	#if   TIMER1_OVERFLOW_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 Overflow Interrupt */
				SET_BIT(TIMSK,TIMSK_TOIE1);
	#elif TIMER1_OVERFLOW_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 Overflow Interrupt */
				CLEAR_BIT(TIMSK,TIMSK_TOIE1);
	#else
		#error "Wrong Timer1 Overflow Interrupt Enable Signal Configuration !"
	#endif

	/* Check if Timer1 compare match for channel A interrupt is enabled or not from config file */
	#if   TIMER1_COMPARE_MATCH_A_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 compare match for channel A interrupt */
				SET_BIT(TIMSK,TIMSK_OCIE1A);
	#elif TIMER1_COMPARE_MATCH_A_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 compare match for channel A interrupt */
				CLEAR_BIT(TIMSK,TIMSK_OCIE1A);
	#else
		#error "Wrong Timer1 Compare Match for Channel A Interrupt Enable Signal Configuration !"
	#endif

	/* Check if Timer1 compare match for channel B interrupt is enabled or not from config file */
	#if   TIMER1_COMPARE_MATCH_B_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 compare match for channel B interrupt */
				SET_BIT(TIMSK,TIMSK_OCIE1B);
	#elif TIMER1_COMPARE_MATCH_B_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 compare match for channel B interrupt */
				CLEAR_BIT(TIMSK,TIMSK_OCIE1B);
	#else
		#error "Wrong Timer1 Compare Match for Channel B Interrupt Enable Signal Configuration !"
	#endif

	/* Check if Timer1 capture event interrupt is enabled or not from config file */
	#if   TIMER1_CAPTURE_EVENT_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 capture event interrupt */
				SET_BIT(TIMSK,TIMSK_TICIE1);
	#elif TIMER1_CAPTURE_EVENT_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 capture event interrupt */
				CLEAR_BIT(TIMSK,TIMSK_TICIE1);
	#else
		#error
	#endif
}
/**********************************************************************************/
/* Description     : Start Timer1 by setting Timer1 prescaler selected from       */
/* 		     config file					          */
/* Input Arguments : void						          */
/* Return          : void						          */
/**********************************************************************************/
void TIMER1_vidStart(void)
{
	/* Clear Timer1 Clock Selection Bits */
	TCCR1B &= TIMER1_CLK_MASK;

	/* Check Selected Prescaler Value from Config File to Start Timer1 */
	#if   TIMER1_PRESCALER == CLK_DIV_BY_NO_PRESCALER
		/* Set Timer1 clock to be the same as system clock without division by any prescalers */
		TCCR1B |= TIMER1_CLK_DIV_BY_NO_PRESCALER;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_8
		/* Set Timer1 clock to be system clock but divided by 8 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_8;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_64
		/* Set Timer1 clock to be system clock but divided by 64 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_64;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_256
		/* Set Timer1 clock to be system clock but divided by 256 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_256;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_1024
		/* Set Timer1 clock to be system clock but divided by 1024 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_1024;
	#elif TIMER1_PRESCALER == EXT_CLK_FALLING_EDGE
		/* Set Timer1 to work on external clock source on T1 pin (clock on falling edge) */
		TCCR1B |= TIMER1_EXT_CLK_FALLING_EDGE;
	#elif TIMER1_PRESCALER == EXT_CLK_RISING_EDGE
		/* Set Timer1 to work on external clock source on T1 pin (clock on rising edge) */
		TCCR1B |= TIMER1_EXT_CLK_RISING_EDGE;
	#else
			#error
#endif
}
/**********************************************************************************/
/* Description     : Stop Timer1  					          */
/* Input Arguments : void						          */
/* Return          : void						          */
/**********************************************************************************/
void TIMER1_vidStop(void)
{
	/* Clear Timer1 Clock Selection Bits (Stop Timer1) */
	TCCR1B &= TIMER1_CLK_MASK;
}
/**********************************************************************************/
/* Description     : Set preload value					          */
/* Input Arguments : uint16 Copy_uint16PreloadValue                                     */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetPreloadValue(uint16 Copy_uint16PreloadValue)
{
	/* Set Timer1 Preload Value in TCNT1 Register  */
	TCNT1 = Copy_uint16PreloadValue;
}
/**********************************************************************************/
/* Description     : Set compare match A value				          */
/* Input Arguments : uint16 Copy_uint16CompareMatchAValue                               */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetCompareMatchAValue(uint16 Copy_uint16CompareMatchAValue)
{
	/* Set Timer1 Compare Match Value for Channel A in OCR1A Register */
	OCR1A = Copy_uint16CompareMatchAValue;
}
/**********************************************************************************/
/* Description     : Set compare match B value				          */
/* Input Arguments : uint16 Copy_uint16CompareMatchBValue                               */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetCompareMatchBValue(uint16 Copy_uint16CompareMatchBValue)
{
	/* Set Timer1 Compare Match Value for Channel B in OCR1B Register */
	OCR1B = Copy_uint16CompareMatchBValue;
}
/**********************************************************************************/
/* Description     : Set input capture value				          */
/* Input Arguments : uint16 Copy_uint16InputCaptureValue                                */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetInputCaptureValue(uint16 Copy_uint16InputCaptureValue)
{
	/* Set Timer1 Input Capture Value in ICR1 Register */
	ICR1 = Copy_uint16InputCaptureValue;
}
/**********************************************************************************/
/* Description     : Read Timer/Counter1 Value				          */
/* Input Arguments : void                                                         */
/* Return          : uint16                                		          */
/**********************************************************************************/
uint16 TIMER1_uint16ReadTimerValue(void)
{
	/* Return Timer/Counter1 Value */
	return TCNT1;
}
/**********************************************************************************/
/* Description     : Read Timer1 Input Capture Value			          */
/* Input Arguments : void                                                         */
/* Return          : void                                		          */
/**********************************************************************************/
uint16 TIMER1_uint16ReadInputCaptureValue(void)
{
	/* Return Timer1 Input Capture Value */
	return ICR1;
}
/**********************************************************************************/
/* Description     : Enable Timer1 Overflow Interrupt			          */
/* Input Arguments : void                                                         */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidEnableOverflowInterrupt(void)
{
	/* Enable Timer1 Overflow Interrupt */
	SET_BIT(TIMSK,TIMSK_TOIE1);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Overflow Interrupt			          */
/* Input Arguments : void                        			          */
/* Return          : void                               	                  */
/**********************************************************************************/
void TIMER1_vidDisableOverflowInterrupt(void)
{
	/* Disable Timer1 Overflow Interrupt */
	CLEAR_BIT(TIMSK,TIMSK_TOIE1);
}
/**********************************************************************************/
/* Description     : Enable Timer1 Compare Match A Interrupt		          */
/* Input Arguments : void                            		    	          */
/* Return          : void                       		                  */
/**********************************************************************************/
void TIMER1_vidEnableCompareMatchAInterrupt(void)
{
	/* Enable Timer1 compare match for channel A interrupt */
	SET_BIT(TIMSK,TIMSK_OCIE1A);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Compare Match A Interrupt		          */
/* Input Arguments : void                       				  */
/* Return          : void                    			                  */
/**********************************************************************************/
void TIMER1_vidDisableCompareMatchAInterrupt(void)
{
	/* Disable Timer1 compare match for channel A interrupt */
	CLEAR_BIT(TIMSK,TIMSK_OCIE1A);
}
/**********************************************************************************/
/* Description     : Enable Timer1 Compare Match B Interrupt		          */
/* Input Arguments : void                            		    	          */
/* Return          : void                       		                  */
/**********************************************************************************/
void TIMER1_vidEnableCompareMatchBInterrupt(void)
{
	/* Enable Timer1 compare match for channel B interrupt */
	SET_BIT(TIMSK,TIMSK_OCIE1B);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Compare Match B Interrupt		          */
/* Input Arguments : void                       				  */
/* Return          : void                    			                  */
/**********************************************************************************/
void TIMER1_vidDisableCompareMatchBInterrupt(void)
{
	/* Disable Timer1 compare match for channel B interrupt */
	CLEAR_BIT(TIMSK,TIMSK_OCIE1B);
}
/**********************************************************************************/
/* Description     : Enable Timer1 Capture Event Interrupt		          */
/* Input Arguments : void                            		    	          */
/* Return          : void                       		                  */
/**********************************************************************************/
void TIMER1_vidEnableCaptureEventInterrupt(void)
{
	/* Enable Timer1 capture event interrupt */
	SET_BIT(TIMSK,TIMSK_TICIE1);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Capture Event Interrupt		          */
/* Input Arguments : void                       				  */
/* Return          : void                    			                  */
/**********************************************************************************/
void TIMER1_vidDisableCaptureEventInterrupt(void)
{
	/* Disable Timer1 capture event interrupt */
	CLEAR_BIT(TIMSK,TIMSK_TICIE1);
}
/**********************************************************************************/
/* Description     : Set Timer1 Input Capture Event Trigger Edge 		  */
/* 		     (Rising or Falling) Edge				          */
/* Input Arguments : TIMER1_ICUTriggerEdge_e Copy_EdgeType_e         	          */
/* Return          : uint8                   			                  */
/**********************************************************************************/
uint8 TIMER1_uint8SetInputCaptureEventEdge(TIMER1_ICUTriggerEdge_e Copy_EdgeType_e)
{
	/* Local Variables Definitions */
	uint8 Local_uint8ErrorStatus = RT_OK;   	/* A variable to hold function error status */
	uint8 Local_uint8TCCR1BTemp; 			/* Temporary Variable to Hold Current TCCR1B Register Value */

	/* Read Current Value of TCCR1B Register then Assign it to Local_uint8TCCR1BTemp */
	Local_uint8TCCR1BTemp = TCCR1B;

	/* Clear ICES1 Bit in TCCR1B */
	CLEAR_BIT(Local_uint8TCCR1BTemp,TCCR1B_ICES1);

	/* Check if passed value is valid or not */
	switch(Copy_EdgeType_e)
	{
	case TIMER1_ICU_FALLING_EDGE:

		/* Set Timer1 Input Capture Event Trigger Edge as Falling Edge */
		CLEAR_BIT(Local_uint8TCCR1BTemp,TCCR1B_ICES1);

		/* Write Modified Value of Local_uint8TCCR1BTemp Back Again to TCCR1B Register */
		TCCR1B = Local_uint8TCCR1BTemp;

		break;

	case TIMER1_ICU_RISING_EDGE:

		/* Set Timer1 Input Capture Event Trigger Edge as Falling Edge */
		SET_BIT(Local_uint8TCCR1BTemp,TCCR1B_ICES1);

		/* Write Modified Value of Local_uint8TCCR1BTemp Back Again to TCCR1B Register */
		TCCR1B = Local_uint8TCCR1BTemp;

		break;

	default:

	         /* Function is not working as expected */
	         Local_uint8ErrorStatus = RT_NOK;
	}
	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 overflow ISR is triggered		  */
/* Input Arguments : void(*Copy_pvTIMER1OverflowFunc)(void)		          */
/* Return          : uint8						                  */
/**********************************************************************************/
uint8 TIMER1_uint8SetOverflowCallback(void(*Copy_pvTIMER1OverflowFunc)(void))
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1OverflowFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_uint8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Overflow Callback Function */
		TIMER1_pvCaptureEventCallbackFunc = Copy_pvTIMER1OverflowFunc;
	}
	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 compare match A ISR is triggered	  */
/* Input Arguments : void(*Copy_pvTIMER1CompareMatchAFunc)(void)		  */
/* Return          : uint8						                  */
/**********************************************************************************/
uint8 TIMER1_uint8SetCompareMatchACallback(void(*Copy_pvTIMER1CompareMatchAFunc)(void))
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1CompareMatchAFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_uint8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Compare Match For Channel A Function */
		TIMER1_pvComapareMatchACallbackFunc = Copy_pvTIMER1CompareMatchAFunc;
	}
	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 compare match B ISR is triggered	  */
/* Input Arguments : void(*Copy_pvTIMER1CompareMatchBFunc)(void)		  */
/* Return          : uint8						                  */
/**********************************************************************************/
uint8 TIMER1_uint8SetCompareMatchBCallback(void(*Copy_pvTIMER1CompareMatchBFunc)(void))
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1CompareMatchBFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_uint8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Compare Match For Channel A Function */
		TIMER1_pvComapareMatchBCallbackFunc = Copy_pvTIMER1CompareMatchBFunc;
	}
	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 capture event ISR is triggered	  */
/* Input Arguments : void(*Copy_pvTIMER1CaptureEventFunc)(void)		 	  */
/* Return          : uint8						                  */
/**********************************************************************************/
uint8 TIMER1_uint8SetCaptureEventCallback(void(*Copy_pvTIMER1CaptureEventFunc)(void))
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1CaptureEventFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_uint8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Capture Event Function */
		TIMER1_pvCaptureEventCallbackFunc = Copy_pvTIMER1CaptureEventFunc;
	}
	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : A function used to delay the processor for some time in      */
/*		     milli-second based on passed value of time in milli-second   */
/* Input Arguments : uint32 Copy_uint32DelayTime_ms				          */
/* Return          : uint8                                                	          */
/**********************************************************************************/
uint8 TIMER1_uint8SetBusyWait_ms(uint32 Copy_uint32DelayTime_ms)
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;	   /* A variable to hold function error status */

	/* Check if passed value in milli-second is out of range or not */
	if(Copy_uint32DelayTime_ms < 4294967296)
	{
		float32 Local_float32DelayTime_s;               /* A variable to hold passed delay time in seconds */

		uint32 Local_uint32OverflowNum;		/* A variable to hold number of overflows required for Timer1 to achieve passed delay */

		uint32 Local_uint32OverflowCounter = 0;	/* A variable to count the number of overflows */

		uint16 Local_uint16PreloadValue ;		/* A variable to hold preload value to be calculated */

		/* Convert passed delay from milli-second to second */
		Local_float32DelayTime_s = (float32)Copy_uint32DelayTime_ms * 0.001f;

		/* Get number of overflows required for Timer1 to reach passed delay */
//		Local_uint32OverflowNum = SERV_uint32CeilDev(Local_float32DelayTime_s,Global_float32Timer1OverflowTime);

		/* Get Preload Value */
		Local_uint16PreloadValue = TIMER1_uint16CalculateTimer1PreloadVal(Local_float32DelayTime_s,Local_uint32OverflowNum);

		/* Set Preload Value */
		TIMER1_vidSetPreloadValue(Local_uint16PreloadValue);

		/* Start Timer 1 */
		TIMER1_vidStart();

		/* Wait until the delay is finished */
		while(Local_uint32OverflowCounter < Local_uint32OverflowNum)
		{
			/* Wait until TOV1 Flag is set by hardware */
			while(GET_BIT(TIFR,TIFR_TOV1) != 1);

			/* Clear TOV1 Flag by writing 1 to its bit in TIFR Register */
			SET_BIT(TIFR,TIFR_TOV1);

			/* Increment Overflow Counter */
			Local_uint32OverflowCounter++;
		}

		/* Stop Timer1 */
		TIMER1_vidStop();
	}
	else
	{
		/* Function is not working as expected */
		Local_uint8ErrorStatus = RT_NOK;
	}
	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Start to generate PWM from Timer1 Output Compare Match 	  */
/*		     Channel A						          */
/* Input Arguments : uint8 Copy_uint8DutyCyclePercentage				  */
/* Return          : void						          */
/**********************************************************************************/
uint8 TIMER1_uint8StartPWMChannelA(uint8 Copy_uint8DutyCyclePercentage)
{

	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed value is out of range or not */
	if(Copy_uint8DutyCyclePercentage <= 100)
	{
		/* Set Duty Cycle Percentage */
		TIMER1_uint8SetDutyCycleChA(Copy_uint8DutyCyclePercentage);

		/* Start Timer1 */
		TIMER1_vidStart();
	}
	else
	{
		/* Function is not working as expected */
		Local_uint8ErrorStatus = RT_NOK;
	}
	return Local_uint8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Start to generate PWM from Timer1 Output Compare Match 	  */
/*		     Channel B						          */
/* Input Arguments : uint8 Copy_uint8DutyCyclePercentage				  */
/* Return          : void						          */
/**********************************************************************************/
uint8 TIMER1_uint8StartPWMChannelB(uint8 Copy_uint8DutyCyclePercentage)
{
	/* Define Some Local Variables */
	uint8 Local_uint8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed value is out of range or not */
	if(Copy_uint8DutyCyclePercentage <= 100)
	{
		/* Set Duty Cycle Percentage */
		TIMER1_uint8SetDutyCycleChB(Copy_uint8DutyCyclePercentage);

		/* Start Timer1 */
		TIMER1_vidStart();
	}
	else
	{
		/* Function is not working as expected */
		Local_uint8ErrorStatus = RT_NOK;
	}
	return Local_uint8ErrorStatus;
}

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                            	  INTERRUPT HANDLERS		                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

/************************************************/
/*   Timer/Counter1 Capture Event Interrupt	*/
/************************************************/
void __vector_6 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_6 (void)
{
	/* Check if Timer1 capture event function is registered or not */
	if(TIMER1_pvCaptureEventCallbackFunc != NULL)
	{
		/* Invoke Timer1 capture event function */
		TIMER1_pvCaptureEventCallbackFunc();
	}
}
/************************************************/
/*   Timer/Counter1 Compare Match A Interrupt	*/
/************************************************/
void __vector_7 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_7 (void)
{
	/* Check if Timer1 compare match for channel A function is registered or not */
	if(TIMER1_pvComapareMatchACallbackFunc != NULL)
	{
		/* Invoke Timer1 compare match for channel A function */
		TIMER1_pvComapareMatchACallbackFunc();
	}
}
/************************************************/
/*   Timer/Counter1 Compare Match B Interrupt	*/
/************************************************/
ISR(VECTOR_8)
{
	/* Check if Timer1 compare match for channel B function is registered or not */
	if(TIMER1_pvComapareMatchBCallbackFunc != NULL)
	{
		/* Invoke Timer1 compare match for channel B function */
		TIMER1_pvComapareMatchBCallbackFunc();
	}
}
/************************************************/
/* 	Timer/Counter1 Overflow Interrupt	*/
/************************************************/
ISR(VECTOR_9)
{
	/* Check if Timer1 overflow function is registered or not */
	if(TIMER1_pvOverflowCallbackFunc != NULL)
	{
		/* Invoke Timer1 overflow function */
		TIMER1_pvOverflowCallbackFunc();
	}
}
